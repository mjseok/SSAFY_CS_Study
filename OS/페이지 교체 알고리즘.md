### 개요
가상 메모리는 요구 페이지 기법을 통해 필요한 페이지만 메모리에 적재하고 사용하지 않는 부분은 그대로 둔다.<br>
하지만 필요한 페이지만 올려도 메모리는 결국 가득 차게 되고, 올라와있던 페이지가 사용이 다 된 후에도 자리만 차지하고 있을 수 있다.<br>
따라서 메모리가 가득 찰 경우, 추가로 페이지를 가져오기 위해서 안쓰는 페이지를 지우고, 해당 공간에 현재 필요한 페이지를 가져와야 한다.<br>
이와 같이 필요한 페이지가 메모리에 적재되지 않은 경우를 페이지 부재(page-falut)라고 한다.<br>
또, 지우는 페이지를 희생 페이지(victim page)라 하는데, 희생 페이지를 고르는 알고리즘을 페이지 교체 알고리즘이라 한다.<br>

페이지 교체 알고리즘의 궁극적인 목표는 **페이지 부재의 발생 비율을 줄이는 것**이다.

### 1. FIFO 알고리즘 (First In First Out)
- 말 그대로 가장 먼저 메모리에 올라온 페이지를 가장 먼저 내보내는 알고리즘
- 구현은 간단하지만 성능은 좋지 않은 편
- 들어온 시간을 저장하거나 올라온 순서를 큐를 이용해 저장
- 벨레이디의 모순(Belady's Anomaly) 현상이 발생 가능
![image](https://user-images.githubusercontent.com/44194990/196169972-fa05d5ec-d12b-4bf5-bf91-3bcdf4706cb6.png)
<br><br><br>
#### 벨레이디의 모순 (Belady's Anomaly)
프레임의 개수가 많아져도 페이지 부재가 줄어들지 않고 늘어나는 현상
![image](https://user-images.githubusercontent.com/44194990/196171490-36851192-a922-4a7f-8258-c4ebc395012e.png)
<br><br><br>

### 2. OPT 알고리즘 (Optimal)
- 앞으로 가장 오랫동안 사용하지 않을 페이지를 교체하는 알고리즘
- 모든 페이지 교체 알고리즘 중 page-fault 발생이 가장 적음
- 벨레이디의 모순(Belady's Anomaly) 현상이 발생하지 않음
- 프로세스가 앞으로 사용할 페이지를 미리 알아야하므로 **실제로 구현하기 (거의) 불가능**한 알고리즘
- 연구 목적을 위해 사용<br>
![image](https://user-images.githubusercontent.com/44194990/196173414-cfd00b90-2aeb-4bb8-be69-8693a75ba5d9.png)
<br><br><br>

### 3. LRU 알고리즘 (Least Recently Used)
- 가장 오랫동안 사용하지 않은 페이지를 교체하는 알고리즘
- 성능이 좋은 편
- 많은 운영체제가 채택하는 알고리즘
![image](https://user-images.githubusercontent.com/44194990/196174280-8f641100-92b3-47f3-a68e-88731e5b1016.png)
<br><br><br>

### 4. LFU 알고리즘 (Least Frequently Used)
- 참조횟수가 가장 적은 페이지를 교체하는 알고리즘
- 교체 대상이 여러 개라면 가장 오랫동안 사용하지 않은 페이지를 교체
- LRU는 직전 참조된 시점만을 반영하는 반면, LFU는 참조 횟수를 통해 장기적 시간규모에서의 참조 성향을 고려할 수 있음
- 가장 최근에 불러온 페이지가 교체될 수 있다는 단점이 있음
![image](https://user-images.githubusercontent.com/44194990/196175881-867a9e20-6738-4830-948e-9a293a6a0add.png)
